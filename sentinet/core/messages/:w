import sys
from struct import pack
from sentinet.core.messages.MessageKeys import *

# Data message can recieve or send messages
class Data_Message:

    # Create a message first, then you can recieve messages
    def __init__(self): 

        # Recieve the default header for backwards compatability sake
        self.header = default_header

        # Get the size of the header (TODO - this is still to explicit)
        # Notice the + 1, that's for null terminator
        self.header_size = self.header["FIELDS"].index + self.header["FIELDS"].data_size + 1

        # Create a new byte array
        self.message = bytearray(self.header_size) 

        # Serialize header, if an error occurs here
        # it's not a runtime issue, its a versioning one
        if not self.serialize_header():
            print("Exiting")
            sys.exit(1)
        
        # For faster retrivals of data, 
        # store the indexes of each element in
        # indices
        self.indices = []

    # Just serielaizes header
    # This is called on to_wire
    def serialize_header(self):
        i = 0 
        # For every data element, serialize it into the header
        for element in self.header.values():
            if i != element.index:
                print("Error - invalid header index")
                return False
            self.message[i:i+element.data_size] = element.serialize()
            i += element.data_size
        # Add a null terminator
        self.message[i] = 0
        return True
     
    # Returns element that is in the message header
    def get_header_element_raw(self, size, index):
        if index + size > self.header_size:
            print("Error, invalid range")
            return None
        return int.from_bytes(self.message[index:index+size], byteorder = ENDIAN, signed=False)

    # Serialize a data element onto the top of a buffer
    def serialize_data_push(self, data, bytes_size, type_code):
        if type_code in serialize_funcs:
            if serialize_funcs[type_code][0](data, bytes_size):
                data = serialize_funcs[type_code][1](data)
            else:
                print("Invalid data type for declared type code")
                return False
        else:
            print("Invalid type code")
            return False
        
        # So we can reference data later on
        self.indices.append(self.header["BYTE_LENGTH"].data)
        # First, the message size (1 byte)
        self.message.append(bytes_size)
        # Second the message type code in utf (1 byte)
        self.message.append(ord(type_code))
        # Third, the data
        self.message.extend(data)
        # Fourth the null terminator
        self.message.append(0)
        # Update header fields and byte length
        self.header["FIELDS"].data += 1
        self.header["BYTE_LENGTH"].data += 3 + bytes_size

    # Serialize a data element into a buffer
    def serialize_data_set(self, data, bytes_size, type_code, index):
        if index >= self.header["FIELDS"].data and bytes_size < 256:
            print("Invalid index")
            return False
        if type_code in serialize_funcs:
            if serialize_funcs[type_code][0](data, bytes_size):
                data = serialize_funcs[type_code][1](data)
            else:
                print("Invalid data type for declared type code")
                return False
        else:
            print("Invalid type code")
            return False

        # Index of data
        i = self.indices[index]
        print(type(self.message[i:i+1]))
        # Size of data at index
        size = int.from_bytes(self.message[i:i+1], byteorder = ENDIAN)
        print("asdasdasdad", size)

        # Optimal operations for three cases
        if size == bytes_size:
            self.message[i] = bytes_size
            self.message[i + 1] = ord(type_code)
            self.message[i + 2:i + 2 + bytes_size] = data

        elif size > bytes_size:
            self.message[i] = bytes_size
            self.message[i + 1] = ord(type_code)
            self.message[i + 2:i + 2 + bytes_size] = data
            del self.message[i + 2 + bytes_size: i + 2 + size]
            diff = size - bytes_size
            print(self.indices)
            for i in range(len(self.indices[index+1:len(self.indices)])):
                print("asdasd", self.indices[i])
                self.indices[i] -= diff

        elif size < bytes_size:
            diff = bytes_size - size
            self.message[i] = bytes_size
            self.message[i + 1] = ord(type_code)
            # Figured out that python automatically
            # allocates extra space for data if data
            # size is larger
            self.message[i + 2:i + 2 + size] = data
            for i in range(len(self.indices[index:])):
                self.indices[i] += diff

        self.header["BYTE_LENGTH"].data += (bytes_size - size)
    
    def set_data(self, data: bytes, byte_size: int, type_code, byte_index):
        if self.header["BYTE_LENGTH"].data < byte_index + byte_size + 3:
            print("Index to high, pushing to the top of stack")
            self.serialize_data(data, byte_size, type_code)
            return True
        # Itterate through the message
        print(self.message)
        self.message[byte_index] = byte_size
        self.message[byte_index + 1] = ord(type_code)
        self.message[byte_index + 2:byte_index + byte_size + 2] = data
        self.message[byte_index + byte_size + 2] = 0
         
# A ping message is a lot easier to work with
# Because it's one big header
class Ping_Message:

    def __init__(self, incomming_message = 0):

        # Set it as default to have a standard even if 
        # we simply recieve the message
        self.header = default_ping
        self.header_size = default_ping["EXCESS"].index + default_ping["EXCESS"].data_size + 1

        # If we have no incomming message, create a new packet
        # This could be done in a ternerary, but there may be more we 
        # want to do so I'm leaving it as if else
        if incomming_message == 0:
            self.message = bytearray(self.header_size)

        else: 
            # Check the incomming message - see below TODO
            if self.header_size != len(incomming_message):
                print("Error incomming message size does not match a standard ping message")

            # Copy the message over
            self.message = incomming_message

            # Then itterate through to update the dict values
            for i in self.header.values():
                i.data = self.get_header_element_raw(i.data_size, i.index) 

            # TODO - put all incomming message checks in their
            # own method called validate incomming message
            # Right now, I'm just serializing and expecting
            # nothing to change
            if not self.serialize():
                print("Exiting")
                sys.exit(1)

            if self.message != incomming_message:
                print("Error parsing incomming message")

    # Serialize the data within our message
    def serialize(self):
        i = 0

        # Itterate through all items in the dict and update byte array
        for element in self.header.values():

            # Check for index matching
            if i != element.index:
                print("Error serializing ping, indexes are off")
                return False

            # Otherwise, copy data into the buffer and increment the index
            self.message[i:i+element.data_size] = element.serialize()
            i += element.data_size

        # A null terminator
        self.message[i] = 0
        return True

    # Gets element at a specified key
    def get_element(self, element):
        if element in self.header:
            return self.header[element].data
        else:
            print("Invalid elemet")

    # Gets element at specified index and size in byte form
    def get_element_raw(self, size, index):
        return int.from_bytes(self.message[index:index+size], byteorder = ENDIAN, signed=False)

    # Sets data element in dict (not message)
    def set_element(self, element, value):
        if element in self.header:
            self.header[element].data = value
        else:
            print("Invalid elemet")

    

if __name__ == '__main__':

    # Example:
    dm1 = Data_Message()

    # Serialize some data
    dm1.serialize_data("Hello", 6, STRING)
    dm1.serialize_data(5.9999123123, 4, FLOAT)

    # Shouldn't serialize because the length does not
    # account for null terminator
    print("Expecting ERROR: ")
    dm1.serialize_data("invalid", len("invalid"), STRING)

    # Should serialize
    dm1.serialize_data("valid", len("valid") + 1, STRING)
    
    # Update the header
    dm1.serialize_header()

    # Print some data
    print(dm1.message)
    print("Header byte length: " + str(dm1.header["BYTE_LENGTH"].data))
    print("Actual byte length: " + str(len(dm1.message)))

    # Note that get_header_element_raw should never be used outside,
    # I'm just using it to demonstrate
    print("Byte length in mes: " + str(dm1.get_header_element_raw(4, 6)))

    dm2 = Data_Message(dm1.message)
    dm2.serialize_header()

    # Print some data

    print(dm2.message)
    print("Header byte length: " + str(dm2.header["BYTE_LENGTH"].data))
    print("Actual byte length: " + str(len(dm2.message)))

    # Note that get_header_element_raw should never be used outside,
    # I'm just using it to demonstrate
    print("Byte length in mes: " + str(dm2.get_header_element_raw(4, 6)))


    pm1 = Ping_Message()
    pm1.set_element("TYPE", 0x2)
    pm1.set_element("CHECKSUM", 0x3)
    pm1.set_element("CODE", 1)
    pm1.set_element("EXCESS", 123123123)
    pm1.serialize()
    print(pm1.message)
    print("123123123 = " + str(pm1.get_element_raw(8, 7)))
    print("3 = " + str(pm1.get_element_raw(2, 5)))
    print("1 = " + str(pm1.get_element_raw(2, 3)))
    print("2 = " + str(pm1.get_element_raw(1, 2)))
